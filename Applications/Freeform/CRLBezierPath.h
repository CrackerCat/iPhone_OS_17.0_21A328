//
//     Generated by classdump-c 4.2.0 (64 bit).
//
//  Copyright (C) 1997-2019 Steve Nygard. Updated in 2022 by Kevin Bradley.
//

#import <objc/NSObject.h>

@class MISSING_TYPE, NSArray, NSString;

@interface CRLBezierPath : NSObject
{
    long long sfr_elementCount;	// 8 = 0x8
    long long sfr_elementMax;	// 16 = 0x10
    struct PATHSEGMENT *sfr_head;	// 24 = 0x18
    double *sfr_elementLength;	// 32 = 0x20
    double sfr_totalLength;	// 40 = 0x28
    long long sfr_lastSubpathIndex;	// 48 = 0x30
    void *sfr_extraSegments;	// 56 = 0x38
    double sfr_lineWidth;	// 64 = 0x40
    struct CGRect sfr_bounds;	// 72 = 0x48
    struct CGRect sfr_controlPointBounds;	// 104 = 0x68
    double sfr_miterLimit;	// 136 = 0x88
    double sfr_flatness;	// 144 = 0x90
    double *sfr_dashedLinePattern;	// 152 = 0x98
    unsigned long long sfr_dashedLineCount;	// 160 = 0xa0
    double sfr_dashedLinePhase;	// 168 = 0xa8
    struct CGPath *sfr_path;	// 176 = 0xb0
    long long sfr_extraSegmentCount;	// 184 = 0xb8
    long long sfr_extraSegmentMax;	// 192 = 0xc0
    struct {
        unsigned int sfr_flags:8;
        unsigned int sfr_pathState:2;
        unsigned int sfr_calculatedLengths:1;
        unsigned int sfr_unused:21;
    } sfr_bpFlags;	// 200 = 0xc8
}

+ (void)subdivideBezierWithFlatness:(double)arg1 startPoint:(struct CGPoint)arg2 controlPoint1:(struct CGPoint)arg3 controlPoint2:(struct CGPoint)arg4 endPoint:(struct CGPoint)arg5 addLineBlock:(CDUnknownBlockType)arg6;	// IMP=0x0020000000112fe6
+ (double)defaultLineWidth;	// IMP=0x001000000011118b
+ (void)setDefaultLineWidth:(double)arg1;	// IMP=0x001000000011117d
+ (unsigned long long)defaultLineJoinStyle;	// IMP=0x0010000000111170
+ (void)setDefaultLineJoinStyle:(unsigned long long)arg1;	// IMP=0x0010000000111163
+ (unsigned long long)defaultLineCapStyle;	// IMP=0x0010000000111156
+ (void)setDefaultLineCapStyle:(unsigned long long)arg1;	// IMP=0x0010000000111149
+ (long long)defaultWindingRule;	// IMP=0x001000000011113c
+ (void)setDefaultWindingRule:(long long)arg1;	// IMP=0x001000000011112f
+ (double)defaultFlatness;	// IMP=0x0010000000111121
+ (void)setDefaultFlatness:(double)arg1;	// IMP=0x0010000000111113
+ (double)defaultMiterLimit;	// IMP=0x0010000000111105
+ (void)setDefaultMiterLimit:(double)arg1;	// IMP=0x00100000001110f7
+ (void)strokeLineFromPoint:(struct CGPoint)arg1 toPoint:(struct CGPoint)arg2;	// IMP=0x001000000011102c
+ (void)clipRect:(struct CGRect)arg1;	// IMP=0x0010000000111006
+ (void)strokeRect:(struct CGRect)arg1;	// IMP=0x0010000000110e1a
+ (void)fillRect:(struct CGRect)arg1;	// IMP=0x0010000000110df4
+ (id)bezierPathWithCGPath:(struct CGPath *)arg1;	// IMP=0x0010000000110b81
+ (id)bezierPathWithOvalInRect:(struct CGRect)arg1;	// IMP=0x0010000000110b38
+ (id)bezierPathWithRect:(struct CGRect)arg1;	// IMP=0x0010000000110aef
+ (id)bezierPathWithDefaultsForErrorCases;	// IMP=0x0010000000110ac2
+ (id)bezierPathWithStart:(struct CGPoint)arg1 end:(struct CGPoint)arg2;	// IMP=0x0010000000110a55
+ (id)bezierPath;	// IMP=0x0010000000110a43
+ (void)initialize;	// IMP=0x0010000000110a03
+ (id)tracedPathForInstantAlphaBinaryBitmap:(id)arg1 pointSpacing:(double)arg2;	// IMP=0x001000000004b871
+ (id)tracedPathForImage:(struct CGImage *)arg1 alphaThreshold:(double)arg2 pointSpacing:(double)arg3;	// IMP=0x001000000004ae9c
+ (double)lineWidth;	// IMP=0x00100000001195b2
+ (void)setLineWidth:(double)arg1;	// IMP=0x00100000001195a0
+ (unsigned long long)lineJoinStyle;	// IMP=0x001000000011958e
+ (void)setLineJoinStyle:(unsigned long long)arg1;	// IMP=0x001000000011957c
+ (unsigned long long)lineCapStyle;	// IMP=0x001000000011956a
+ (void)setLineCapStyle:(unsigned long long)arg1;	// IMP=0x0010000000119558
+ (long long)windingRule;	// IMP=0x0010000000119546
+ (void)setWindingRule:(long long)arg1;	// IMP=0x0010000000119534
+ (double)flatness;	// IMP=0x0010000000119522
+ (void)setFlatness:(double)arg1;	// IMP=0x0010000000119510
+ (double)miterLimit;	// IMP=0x00100000001194fe
+ (void)setMiterLimit:(double)arg1;	// IMP=0x00100000001194ec
+ (id)appendBezierPaths:(id)arg1;	// IMP=0x001000000012e1be
+ (struct CGPoint)p_findPointWithGreatestSlopeFromStartPoint:(struct CGPoint)arg1 toPointA:(struct CGPoint)arg2 orPointB:(struct CGPoint)arg3;	// IMP=0x0010000000126978
+ (id)bezierPathWithConvexHullOfPoints:(struct CGPoint *)arg1 count:(unsigned long long)arg2;	// IMP=0x001000000012660e
+ (id)smoothBezierPath:(id)arg1 withThreshold:(double)arg2;	// IMP=0x0010000000126119
+ (id)exteriorOfBezierPath:(id)arg1;	// IMP=0x0010000000125eec
+ (id)excludeBezierPaths:(id)arg1;	// IMP=0x0010000000125ebb
+ (id)subtractBezierPaths:(id)arg1;	// IMP=0x0010000000125e01
+ (id)intersectBezierPaths:(id)arg1;	// IMP=0x0010000000125d47
+ (id)uniteBezierPaths:(id)arg1;	// IMP=0x0010000000125c90
+ (CDStruct_46b2202e)lineEndPositioningOnPath:(id)arg1 atHead:(_Bool)arg2 headPoint:(struct CGPoint)arg3 tailPoint:(struct CGPoint)arg4 headLineEnd:(id)arg5 tailLineEnd:(id)arg6 stroke:(id)arg7;	// IMP=0x00100000002a000f
+ (id)createClippedPath:(id)arg1 headPositioning:(CDStruct_46b2202e)arg2 tailPositioning:(CDStruct_46b2202e)arg3 stroke:(id)arg4;	// IMP=0x001000000029fd5a
+ (CDStruct_46b2202e)p_makeDefaultPositioning;	// IMP=0x001000000029fd26
+ (double)minimumLengthForSideToHaveFullContinuityWithCornerRadius1:(double)arg1 cornerRadius2:(double)arg2;	// IMP=0x001000000046b41e
+ (id)bezierPathWithRoundedRect:(struct CGRect)arg1 upperRightRadius:(double)arg2 lowerRightRadius:(double)arg3 lowerLeftRadius:(double)arg4 upperLeftRadius:(double)arg5 useLegacyCorners:(_Bool)arg6 keepNoOpElements:(_Bool)arg7;	// IMP=0x001000000046af6b
+ (id)bezierPathWithLegacyRoundedRect:(struct CGRect)arg1 cornerRadius:(double)arg2;	// IMP=0x001000000046af46
+ (MISSING_TYPE *)bezierPathWithContinuousCornerRoundedRect:cornerRadius: /* Error: Ran out of types for this method. */;	// IMP=0x001000000046af24
+ (id)pathForObjectEraserWithPoint:(struct CGPoint)arg1;	// IMP=0x0010000000b5bae0
- (id)initWithCString:(const char *)arg1;	// IMP=0x0010000000118574
- (const char *)cString;	// IMP=0x00100000001180ee
- (_Bool)containsPoint:(struct CGPoint)arg1;	// IMP=0x001000000011806a
- (void)appendBezierPathWithArcFromPoint:(struct CGPoint)arg1 toPoint:(struct CGPoint)arg2 radius:(double)arg3;	// IMP=0x0010000000117c4b
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint)arg1 radius:(double)arg2 startAngle:(double)arg3 endAngle:(double)arg4;	// IMP=0x0010000000117c34
- (void)appendBezierPathWithArcWithCenter:(struct CGPoint)arg1 radius:(double)arg2 startAngle:(double)arg3 endAngle:(double)arg4 clockwise:(_Bool)arg5;	// IMP=0x00100000001176c7
- (void)_appendArcSegmentWithCenter:(struct CGPoint)arg1 radius:(double)arg2 angle1:(double)arg3 angle2:(double)arg4;	// IMP=0x001000000011759e
- (void)appendBezierPathWithOvalInRect:(struct CGRect)arg1;	// IMP=0x00100000001173c3
- (void)appendBezierPathWithPoints:(struct CGPoint *)arg1 count:(long long)arg2;	// IMP=0x0010000000117314
- (void)appendBezierPathWithRect:(struct CGRect)arg1;	// IMP=0x0010000000117203
- (id)copyWithPointsInRange:(struct _NSRange)arg1 countingSubpaths:(unsigned long long *)arg2;	// IMP=0x00100000001170fe
- (id)copyWithPointsInRange:(struct _NSRange)arg1;	// IMP=0x00100000001170d8
- (void)p_appendPointsInRange:(struct _NSRange)arg1 fromBezierPath:(id)arg2 countingSubpaths:(unsigned long long *)arg3;	// IMP=0x0010000000116c12
- (void)appendPointsInRange:(struct _NSRange)arg1 fromBezierPath:(id)arg2;	// IMP=0x0010000000116bec
- (void)appendBezierPath:(id)arg1;	// IMP=0x0010000000116bd8
- (void)appendBezierPath:(id)arg1 skippingInitialMoveIfPossible:(_Bool)arg2;	// IMP=0x00100000001169f8
- (void)_appendToPath:(id)arg1 skippingInitialMoveIfPossible:(_Bool)arg2;	// IMP=0x001000000011689e
- (void)setAssociatedPoints:(struct CGPoint *)arg1 atIndex:(long long)arg2;	// IMP=0x00100000001165d6
- (long long)elementAtIndex:(long long)arg1 allPoints:(struct CGPoint *)arg2;	// IMP=0x0010000000116304
- (void)iteratePathElementsWithBlock:(CDUnknownBlockType)arg1;	// IMP=0x00100000001161b9
- (long long)elementAtIndex:(long long)arg1 associatedPoints:(struct CGPoint *)arg2;	// IMP=0x0010000000115b8e
- (long long)elementAtIndex:(long long)arg1;	// IMP=0x0010000000115b7a
- (long long)elementCount;	// IMP=0x0010000000115b70
- (double)lengthToElement:(long long)arg1;	// IMP=0x0010000000115784
- (double)lengthOfElement:(long long)arg1;	// IMP=0x00100000001154fe
- (double)length;	// IMP=0x00100000001154d0
- (void)calculateLengths;	// IMP=0x0010000000115431
- (double)calculateLengthOfElement:(long long)arg1;	// IMP=0x001000000011513f
@property(readonly, nonatomic) _Bool containsClosePathElement;
- (_Bool)isClockwise;	// IMP=0x0010000000114bf3
- (_Bool)isFlat;	// IMP=0x0010000000114be2
@property(readonly, nonatomic) struct CGRect bounds;
- (struct CGRect)controlPointBounds;	// IMP=0x00100000001148a4
- (struct CGPoint)currentPoint;	// IMP=0x0010000000114708
- (_Bool)isEmpty;	// IMP=0x00100000001146fa
- (_Bool)isCircular;	// IMP=0x0010000000114504
- (_Bool)isRectangular;	// IMP=0x0010000000114172
- (_Bool)isDiamond;	// IMP=0x0010000000113f23
- (_Bool)isTriangular;	// IMP=0x0010000000113dc6
- (struct CGPath *)CGPath;	// IMP=0x0010000000113d88
- (void)transformUsingAffineTransform:(struct CGAffineTransform)arg1;	// IMP=0x0010000000113b13
- (void)convertCloseElementsToLineElements;	// IMP=0x0010000000113aa8
- (id)p_bezierPathByRemovingRedundantElementAndSubregionsSmallerThanThreshold:(double)arg1;	// IMP=0x00100000001135bf
- (id)bezierPathByRemovingRedundantElements;	// IMP=0x00100000001135aa
- (id)bezierPathByRemovingSmallSubpathsForInteriorWrapsForInset:(double)arg1;	// IMP=0x0010000000113594
- (id)bezierPathByReversingPath;	// IMP=0x00100000001133bf
- (id)_copyFlattenedPath;	// IMP=0x001000000011338a
- (id)bezierPathByFlatteningPathWithFlatness:(double)arg1;	// IMP=0x0010000000113316
- (id)bezierPathByFlatteningPath;	// IMP=0x00100000001132fc
- (void)flattenIntoPath:(id)arg1 flatness:(double)arg2;	// IMP=0x00100000001131c9
- (void)flattenIntoPath:(id)arg1;	// IMP=0x00100000001131af
- (void)p_subdivideBezierWithFlatness:(double)arg1 startPoint:(struct CGPoint)arg2 controlPoint1:(struct CGPoint)arg3 controlPoint2:(struct CGPoint)arg4 endPoint:(struct CGPoint)arg5;	// IMP=0x0010000000112f48
- (void)addClip;	// IMP=0x0010000000112e18
- (void)fill;	// IMP=0x0000000000112ce8
- (void)stroke;	// IMP=0x0010000000112b3c
- (void)_doPath;	// IMP=0x0010000000112988
- (struct CGPoint)_checkPointForValidity:(struct CGPoint)arg1;	// IMP=0x00100000001127ac
- (_Bool)_isValid:(double)arg1;	// IMP=0x001000000011277a
- (void)getLineDash:(double *)arg1 count:(long long *)arg2 phase:(double *)arg3;	// IMP=0x0010000000112722
- (void)setLineDash:(const double *)arg1 count:(long long)arg2 phase:(double)arg3;	// IMP=0x001000000011263c
@property(nonatomic) double flatness;
@property(nonatomic) double miterLimit;
@property(nonatomic) long long windingRule;
@property(nonatomic) unsigned long long lineJoinStyle;
@property(nonatomic) unsigned long long lineCapStyle;
@property(nonatomic) double lineWidth;
- (void)relativeCurveToPoint:(struct CGPoint)arg1 controlPoint1:(struct CGPoint)arg2 controlPoint2:(struct CGPoint)arg3;	// IMP=0x001000000011248c
- (void)relativeCurveToPoint:(struct CGPoint)arg1 controlPoint:(struct CGPoint)arg2;	// IMP=0x00100000001123f0
- (void)relativeLineToPoint:(struct CGPoint)arg1;	// IMP=0x001000000011239b
- (void)relativeMoveToPoint:(struct CGPoint)arg1;	// IMP=0x0010000000112346
- (void)removeAllPoints;	// IMP=0x00100000001122e5
- (void)closePath;	// IMP=0x00100000001122d3
- (void)curveToPoint:(struct CGPoint)arg1 controlPoint1:(struct CGPoint)arg2 controlPoint2:(struct CGPoint)arg3;	// IMP=0x00100000001120f6
- (void)curveToPoint:(struct CGPoint)arg1 controlPoint:(struct CGPoint)arg2;	// IMP=0x0010000000111ed5
- (void)lineToPoint:(struct CGPoint)arg1;	// IMP=0x0010000000111d2b
- (void)moveToPoint:(struct CGPoint)arg1;	// IMP=0x0010000000111d19
- (id)copyWithZone:(struct _NSZone *)arg1;	// IMP=0x00100000001115c6
- (void)copyPathAttributesTo:(id)arg1;	// IMP=0x00100000001114cc
- (unsigned long long)hash;	// IMP=0x00100000001114ba
- (_Bool)isEqual:(id)arg1;	// IMP=0x001000000011131d
- (void)dealloc;	// IMP=0x001000000011128a
- (id)init;	// IMP=0x0010000000111199
- (void)_deviceClosePath;	// IMP=0x00100000001192e4
- (void)_deviceCurveToPoint:(struct CGPoint)arg1 controlPoint1:(struct CGPoint)arg2 controlPoint2:(struct CGPoint)arg3 elementLength:(double)arg4;	// IMP=0x0010000000119004
- (void)_deviceLineToPoint:(struct CGPoint)arg1;	// IMP=0x0010000000118fcc
- (void)_deviceMoveToPoint:(struct CGPoint)arg1;	// IMP=0x0010000000118f3f
- (void)_addPathSegment:(long long)arg1 point:(struct CGPoint)arg2;	// IMP=0x0010000000118b30
- (id)description;	// IMP=0x00100000001195c4
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect)arg1 startRadialVector:(struct CGPoint)arg2 endRadialVector:(struct CGPoint)arg3 angleSign:(unsigned long long)arg4 startNewPath:(_Bool)arg5;	// IMP=0x001000000012ee88
- (void)appendBezierPathWithArcWithEllipseBounds:(struct CGRect)arg1 startAngle:(double)arg2 swingAngle:(double)arg3 angleType:(unsigned long long)arg4 startNewPath:(_Bool)arg5;	// IMP=0x001000000012e2c0
- (void)alignBoundsToOrigin;	// IMP=0x001000000012e0fc
- (id)p_aliasedPathInContext:(struct CGContext *)arg1 viewScale:(float)arg2 effectiveStrokeWidth:(float)arg3;	// IMP=0x001000000012d465
- (id)aliasedPathWithViewScale:(float)arg1 effectiveStrokeWidth:(float)arg2;	// IMP=0x001000000012d451
- (id)aliasedPathInContext:(struct CGContext *)arg1 effectiveStrokeWidth:(float)arg2;	// IMP=0x001000000012d434
- (void)clearStroke:(struct CGContext *)arg1;	// IMP=0x001000000012d31c
- (void)addPathToContext:(struct CGContext *)arg1;	// IMP=0x001000000012d215
- (double)p_yValueFromXValue:(double)arg1 elementIndex:(long long *)arg2 parametricValue:(double *)arg3;	// IMP=0x001000000012c68e
- (double)yValueFromXValue:(double)arg1;	// IMP=0x001000000012c678
- (double)distanceToPoint:(struct CGPoint)arg1 elementIndex:(unsigned long long *)arg2 tValue:(double *)arg3 threshold:(double)arg4 findClosestMatch:(_Bool)arg5;	// IMP=0x001000000012be31
- (struct CGRect)boundsIncludingStrokeWidth:(double)arg1 joinStyle:(unsigned long long)arg2 capStyle:(unsigned long long)arg3 miterLimit:(double)arg4 needsToExtendJoins:(_Bool)arg5;	// IMP=0x001000000012b79e
- (_Bool)intersectsRect:(struct CGRect)arg1 hasFill:(_Bool)arg2;	// IMP=0x001000000012b3ca
- (void)iterateOverPathWithPointDistancePerIteration:(double)arg1 usingBlock:(CDUnknownBlockType)arg2;	// IMP=0x001000000012b211
- (struct CGPoint)pointAlongPathAtPercentage:(double)arg1 withFlattenedPath:(id)arg2 andLength:(double *)arg3 atStartIndex:(unsigned long long *)arg4;	// IMP=0x001000000012a112
- (struct CGPoint)pointAlongPathAtPercentage:(double)arg1;	// IMP=0x001000000012a080
- (_Bool)isVisuallyEqualToPath:(id)arg1 withThreshold:(double)arg2;	// IMP=0x0010000000129d75
- (id)p_elementCountForSubpaths;	// IMP=0x0010000000129c54
- (id)pathSplitAtSubpathBoundariesWithSoftElementLimit:(unsigned long long)arg1 hardElementLimit:(unsigned long long)arg2;	// IMP=0x0010000000129230
- (id)arrayOfSubpathsWithEffectivelyEmptySubpathsRemoved:(_Bool)arg1;	// IMP=0x0010000000128f40
- (id)pathByWobblingByUpTo:(double)arg1 subdivisions:(unsigned long long)arg2;	// IMP=0x0010000000128b09
- (id)pathByCreatingHoleInPathAtPoint:(struct CGPoint)arg1 withDiameter:(CDUnknownBlockType)arg2 andThreshold:(double)arg3 updatingPatternOffsetsBySubpath:(id)arg4;	// IMP=0x0010000000127298
- (id)p_pathBySplittingAtPointGuaranteedToBeOnPath:(struct CGPoint)arg1 controlPointDistanceEqual:(_Bool)arg2 elementIndex:(long long)arg3 parametricValue:(double)arg4;	// IMP=0x0010000000126d38
- (id)pathBySplittingAtPointOnPath:(struct CGPoint)arg1 controlPointDistanceEqual:(_Bool)arg2;	// IMP=0x0010000000126cb7
- (id)bezierPathByOffsettingPath:(double)arg1 joinStyle:(unsigned long long)arg2;	// IMP=0x0010000000126142
- (id)excludeBezierPath:(id)arg1;	// IMP=0x0010000000125e32
- (id)subtractBezierPath:(id)arg1;	// IMP=0x0010000000125d78
- (id)intersectBezierPath:(id)arg1;	// IMP=0x0010000000125cbe
- (id)uniteWithBezierPath:(id)arg1;	// IMP=0x0010000000125c07
- (id)pathByNormalizingClosedPathToRemoveSelfIntersections;	// IMP=0x0010000000125beb
- (id)p_strokedPathByUsingBrushStroke;	// IMP=0x0010000000125a56
- (id)p_strokedPathByUsingCG;	// IMP=0x001000000012596d
- (id)strokedCopy;	// IMP=0x001000000012562f
@property(readonly, nonatomic) NSArray *visuallyDistinctSubregions;
@property(readonly, nonatomic) _Bool hasAtLeastTwoVisuallyDistinctSubregions;
@property(readonly, nonatomic) NSString *inferredLocalizedAccessibilityDescriptionPlaceholder;
@property(readonly, nonatomic) NSString *inferredAccessibilityDescription;
@property(readonly, nonatomic) struct CGRect boundsIncludingStroke;
@property(readonly, nonatomic) double flattenedArea;
@property(readonly, nonatomic) NSArray *rangesOfSubpaths;
@property(readonly, nonatomic) unsigned long long totalSubpathCountIncludingEffectivelyEmptySubpaths;
@property(readonly, nonatomic) _Bool containsElementsOtherThanMoveAndClose;
@property(readonly, nonatomic) _Bool isEffectivelyClosed;
@property(readonly, nonatomic) _Bool isLineSegment;
@property(readonly, nonatomic) _Bool isOpen;
@property(readonly, nonatomic) _Bool isCompound;
- (_Bool)p_equalWidthAndHeightForSize:(struct CGSize)arg1;	// IMP=0x00100000002a0707
- (id)labelForSize:(struct CGSize)arg1;	// IMP=0x00100000002a04ce
- (struct CGRect)boundsIncludingCRLStroke:(id)arg1;	// IMP=0x001000000029f83f
- (void)takeAttributesFromStroke:(id)arg1;	// IMP=0x001000000029f76b
- (id)chisel;	// IMP=0x00100000003fa426
- (void)recursiveSubdivideOntoPath:(id)arg1 withScaling:(CDStruct_c3b9c2ee)arg2 inElementRange:(struct _NSRange)arg3 into:(id)arg4;	// IMP=0x00100000003f9816
- (void)recursiveSubdivideOntoPath:(id)arg1 withScaling:(CDStruct_c3b9c2ee)arg2 into:(id)arg3;	// IMP=0x00100000003f977f
- (void)recursiveSubdivideOntoPath:(id)arg1 into:(id)arg2;	// IMP=0x00100000003f96f4
- (double)curvatureAt:(double)arg1 fromElement:(long long)arg2;	// IMP=0x00100000003f8045
- (double)curvatureAt:(double)arg1;	// IMP=0x00100000003f7fc8
- (struct CGPoint)myGradientAt:(double)arg1 fromElement:(long long)arg2;	// IMP=0x00100000003f7f56
- (struct CGPoint)myGradientAt:(double)arg1;	// IMP=0x00100000003f7ebc
- (struct CGPoint)rawGradientAt:(double)arg1 fromElement:(long long)arg2;	// IMP=0x00100000003f7b9e
- (double)elementPercentageFromElement:(long long)arg1 forOverallPercentage:(double)arg2;	// IMP=0x00100000003f7aec
- (struct CGPoint)transformedTotalCoordinate:(struct CGPoint)arg1 betweenElement:(long long)arg2 andElement:(long long)arg3 getElement:(long long *)arg4 getPercentage:(double *)arg5;	// IMP=0x00100000003f79ca
- (struct CGPoint)gradientAt:(double)arg1;	// IMP=0x00100000003f797e
- (struct CGPoint)gradientAt:(double)arg1 fromElement:(long long)arg2;	// IMP=0x00100000003f7967
- (struct CGPoint)pointAt:(double)arg1;	// IMP=0x00100000003f7714
- (struct CGPoint)pointAt:(double)arg1 fromElement:(long long)arg2;	// IMP=0x00100000003f754d
- (long long)elementPercentage:(double *)arg1 forOverallPercentage:(double)arg2 startingElementIndex:(long long)arg3 lengthToStartingElement:(double)arg4;	// IMP=0x00100000003f7062
- (long long)elementPercentage:(double *)arg1 forOverallPercentage:(double)arg2;	// IMP=0x00100000003f704b
- (struct CGPoint)nearestAngleOnPathToLine:(struct CGPoint [2])arg1;	// IMP=0x00100000003f6a2f
- (struct CGPoint)nearestPointOnPathToLine:(struct CGPoint [2])arg1;	// IMP=0x00100000003f67d5
- (id)copyFromSegment:(int)arg1 t:(double)arg2 toSegment:(int)arg3 t:(double)arg4;	// IMP=0x00100000003f66f8
- (void)appendBezierPath:(id)arg1 fromSegment:(long long)arg2 t:(double)arg3 toSegment:(long long)arg4 t:(double)arg5 withoutMove:(_Bool)arg6;	// IMP=0x00100000003f6148
- (void)appendBezierPath:(id)arg1 fromSegment:(long long)arg2 toSegment:(long long)arg3;	// IMP=0x00100000003f600c
- (void)addIntersectionsWithLine:(struct CGPoint [2])arg1 to:(id)arg2;	// IMP=0x00100000003f5ec1
- (void)addIntersectionsWithPath:(id)arg1 to:(id)arg2;	// IMP=0x00100000003f5ea6
- (void)addIntersectionsWithPath:(id)arg1 to:(id)arg2 allIntersections:(_Bool)arg3 reversed:(_Bool)arg4;	// IMP=0x00100000003f519d
- (void)getStartPoint:(struct CGPoint *)arg1 andEndPoint:(struct CGPoint *)arg2;	// IMP=0x00100000003f50fb

@end

