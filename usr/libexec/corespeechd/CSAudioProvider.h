//
//     Generated by classdump-c 4.2.0 (64 bit).
//
//  Copyright (C) 1997-2019 Steve Nygard. Updated in 2022 by Kevin Bradley.
//

#import <objc/NSObject.h>

@class CSADPPreventStandbyAssertion, CSAudioCircularBuffer, CSAudioPreprocessor, CSAudioRecordContext, CSAudioRecordDeviceIndicator, CSAudioRecorder, CSAudioTimeConverter, CSMicUsageReporter, CSOSTransaction, CSPhoneCallStateMonitor, CSStateCapture, MISSING_TYPE, NSHashTable, NSMutableArray, NSMutableDictionary, NSString, NSUUID;
@protocol CSAudioAlertProvidingDelegate, CSAudioProviderDelegate, CSAudioSessionProvidingDelegate, OS_dispatch_group, OS_dispatch_queue, OS_dispatch_source;

@interface CSAudioProvider : NSObject
{
    _Bool _audioSystemRecovering;	// 8 = 0x8
    _Bool _waitingForAlertFinish;	// 9 = 0x9
    _Bool _currentSessionShouldDuckOnBuiltInSpeaker;	// 10 = 0xa
    NSString *_UUID;	// 16 = 0x10
    NSObject<OS_dispatch_queue> *_recordQueue;	// 24 = 0x18
    NSObject<OS_dispatch_queue> *_loggingQueue;	// 32 = 0x20
    NSObject<OS_dispatch_queue> *_streamHandleQueue;	// 40 = 0x28
    CSAudioRecorder *_audioRecorder;	// 48 = 0x30
    unsigned long long _streamState;	// 56 = 0x38
    NSHashTable *_startPendingStreams;	// 64 = 0x40
    NSHashTable *_startPendingOnStoppingStreams;	// 72 = 0x48
    MISSING_TYPE *_alertPlaybackFinishWaitingStreams;	// 80 = 0x50
    NSHashTable *_streams;	// 88 = 0x58
    NSHashTable *_stopPendingStreams;	// 96 = 0x60
    NSMutableArray *_pendingStartCompletions;	// 104 = 0x68
    NSMutableArray *_alertPlaybackFinishWaitingCompletions;	// 112 = 0x70
    NSMutableArray *_pendingStopCompletions;	// 120 = 0x78
    NSMutableDictionary *_startPendingOnStoppingStreamToCompletionDict;	// 128 = 0x80
    id <CSAudioProviderDelegate> _providerDelegate;	// 136 = 0x88
    id <CSAudioSessionProvidingDelegate> _sessionDelegate;	// 144 = 0x90
    NSMutableArray *_streamHolders;	// 152 = 0x98
    NSHashTable *_historicalBufferRequestStreams;	// 160 = 0xa0
    CSAudioCircularBuffer *_circularBuffer;	// 168 = 0xa8
    id <CSAudioAlertProvidingDelegate> _alertDelegate;	// 176 = 0xb0
    CSAudioRecordContext *_lastAudioRecorderContext;	// 184 = 0xb8
    CSAudioPreprocessor *_audioPreprocessor;	// 192 = 0xc0
    CSOSTransaction *_recordingTransaction;	// 200 = 0xc8
    NSObject<OS_dispatch_group> *_recordingWillStartGroup;	// 208 = 0xd0
    unsigned long long _audioStreamHandleId;	// 216 = 0xd8
    NSUUID *_alertPlaybackFinishTimeoutToken;	// 224 = 0xe0
    NSUUID *_startRecordingWatchDogToken;	// 232 = 0xe8
    NSUUID *_stopRecordingWatchDogToken;	// 240 = 0xf0
    NSObject<OS_dispatch_source> *_audioPacketWatchdog;	// 248 = 0xf8
    unsigned long long _circularBufferStartHostTime;	// 256 = 0x100
    unsigned long long _circularBufferStartSampleCount;	// 264 = 0x108
    CSAudioTimeConverter *_audioTimeConverter;	// 272 = 0x110
    unsigned long long _estimatedStartHostTime;	// 280 = 0x118
    long long _audioStreamType;	// 288 = 0x120
    CSAudioRecordDeviceIndicator *_recordDeviceIndicator;	// 296 = 0x128
    CSMicUsageReporter *_micUsageReporter;	// 304 = 0x130
    unsigned long long _audioPacketDeliveryCount;	// 312 = 0x138
    CSADPPreventStandbyAssertion *_adpAssertion;	// 320 = 0x140
    CSPhoneCallStateMonitor *_phoneCallStateMonitor;	// 328 = 0x148
    unsigned long long _phoneCallState;	// 336 = 0x150
    NSMutableDictionary *_recordModeLocks;	// 344 = 0x158
    NSMutableDictionary *_listeningMicIndicatorLocks;	// 352 = 0x160
    CSStateCapture *_stateCapture;	// 360 = 0x168
}

- (void).cxx_destruct;	// IMP=0x0020000000058382
@property(retain, nonatomic) CSStateCapture *stateCapture; // @synthesize stateCapture=_stateCapture;
@property(retain, nonatomic) NSMutableDictionary *listeningMicIndicatorLocks; // @synthesize listeningMicIndicatorLocks=_listeningMicIndicatorLocks;
@property(retain, nonatomic) NSMutableDictionary *recordModeLocks; // @synthesize recordModeLocks=_recordModeLocks;
@property(nonatomic) _Bool currentSessionShouldDuckOnBuiltInSpeaker; // @synthesize currentSessionShouldDuckOnBuiltInSpeaker=_currentSessionShouldDuckOnBuiltInSpeaker;
@property(nonatomic) unsigned long long phoneCallState; // @synthesize phoneCallState=_phoneCallState;
@property(retain, nonatomic) CSPhoneCallStateMonitor *phoneCallStateMonitor; // @synthesize phoneCallStateMonitor=_phoneCallStateMonitor;
@property(retain, nonatomic) CSADPPreventStandbyAssertion *adpAssertion; // @synthesize adpAssertion=_adpAssertion;
@property(nonatomic) unsigned long long audioPacketDeliveryCount; // @synthesize audioPacketDeliveryCount=_audioPacketDeliveryCount;
@property(retain, nonatomic) CSMicUsageReporter *micUsageReporter; // @synthesize micUsageReporter=_micUsageReporter;
@property(retain, nonatomic) CSAudioRecordDeviceIndicator *recordDeviceIndicator; // @synthesize recordDeviceIndicator=_recordDeviceIndicator;
@property(nonatomic) long long audioStreamType; // @synthesize audioStreamType=_audioStreamType;
@property(nonatomic) unsigned long long estimatedStartHostTime; // @synthesize estimatedStartHostTime=_estimatedStartHostTime;
@property(retain, nonatomic) CSAudioTimeConverter *audioTimeConverter; // @synthesize audioTimeConverter=_audioTimeConverter;
@property(nonatomic) unsigned long long circularBufferStartSampleCount; // @synthesize circularBufferStartSampleCount=_circularBufferStartSampleCount;
@property(nonatomic) unsigned long long circularBufferStartHostTime; // @synthesize circularBufferStartHostTime=_circularBufferStartHostTime;
@property(retain, nonatomic) NSObject<OS_dispatch_source> *audioPacketWatchdog; // @synthesize audioPacketWatchdog=_audioPacketWatchdog;
@property(retain, nonatomic) NSUUID *stopRecordingWatchDogToken; // @synthesize stopRecordingWatchDogToken=_stopRecordingWatchDogToken;
@property(retain, nonatomic) NSUUID *startRecordingWatchDogToken; // @synthesize startRecordingWatchDogToken=_startRecordingWatchDogToken;
@property(retain, nonatomic) NSUUID *alertPlaybackFinishTimeoutToken; // @synthesize alertPlaybackFinishTimeoutToken=_alertPlaybackFinishTimeoutToken;
@property(nonatomic) unsigned long long audioStreamHandleId; // @synthesize audioStreamHandleId=_audioStreamHandleId;
@property(nonatomic) _Bool waitingForAlertFinish; // @synthesize waitingForAlertFinish=_waitingForAlertFinish;
@property(retain, nonatomic) NSObject<OS_dispatch_group> *recordingWillStartGroup; // @synthesize recordingWillStartGroup=_recordingWillStartGroup;
@property(retain, nonatomic) CSOSTransaction *recordingTransaction; // @synthesize recordingTransaction=_recordingTransaction;
@property(retain, nonatomic) CSAudioPreprocessor *audioPreprocessor; // @synthesize audioPreprocessor=_audioPreprocessor;
@property(nonatomic) _Bool audioSystemRecovering; // @synthesize audioSystemRecovering=_audioSystemRecovering;
@property(retain, nonatomic) CSAudioRecordContext *lastAudioRecorderContext; // @synthesize lastAudioRecorderContext=_lastAudioRecorderContext;
@property(nonatomic) __weak id <CSAudioAlertProvidingDelegate> alertDelegate; // @synthesize alertDelegate=_alertDelegate;
@property(retain, nonatomic) CSAudioCircularBuffer *circularBuffer; // @synthesize circularBuffer=_circularBuffer;
@property(retain, nonatomic) NSHashTable *historicalBufferRequestStreams; // @synthesize historicalBufferRequestStreams=_historicalBufferRequestStreams;
@property(retain, nonatomic) NSMutableArray *streamHolders; // @synthesize streamHolders=_streamHolders;
@property(nonatomic) __weak id <CSAudioSessionProvidingDelegate> sessionDelegate; // @synthesize sessionDelegate=_sessionDelegate;
@property(nonatomic) __weak id <CSAudioProviderDelegate> providerDelegate; // @synthesize providerDelegate=_providerDelegate;
@property(retain, nonatomic) NSMutableDictionary *startPendingOnStoppingStreamToCompletionDict; // @synthesize startPendingOnStoppingStreamToCompletionDict=_startPendingOnStoppingStreamToCompletionDict;
@property(retain, nonatomic) NSMutableArray *pendingStopCompletions; // @synthesize pendingStopCompletions=_pendingStopCompletions;
@property(retain, nonatomic) NSMutableArray *alertPlaybackFinishWaitingCompletions; // @synthesize alertPlaybackFinishWaitingCompletions=_alertPlaybackFinishWaitingCompletions;
@property(retain, nonatomic) NSMutableArray *pendingStartCompletions; // @synthesize pendingStartCompletions=_pendingStartCompletions;
@property(retain, nonatomic) NSHashTable *stopPendingStreams; // @synthesize stopPendingStreams=_stopPendingStreams;
@property(retain, nonatomic) NSHashTable *streams; // @synthesize streams=_streams;
@property(retain, nonatomic) NSHashTable *alertPlaybackFinishWaitingStreams; // @synthesize alertPlaybackFinishWaitingStreams=_alertPlaybackFinishWaitingStreams;
@property(retain, nonatomic) NSHashTable *startPendingOnStoppingStreams; // @synthesize startPendingOnStoppingStreams=_startPendingOnStoppingStreams;
@property(retain, nonatomic) NSHashTable *startPendingStreams; // @synthesize startPendingStreams=_startPendingStreams;
@property(nonatomic) unsigned long long streamState; // @synthesize streamState=_streamState;
@property(retain, nonatomic) CSAudioRecorder *audioRecorder; // @synthesize audioRecorder=_audioRecorder;
@property(retain, nonatomic) NSObject<OS_dispatch_queue> *streamHandleQueue; // @synthesize streamHandleQueue=_streamHandleQueue;
@property(retain, nonatomic) NSObject<OS_dispatch_queue> *loggingQueue; // @synthesize loggingQueue=_loggingQueue;
@property(retain, nonatomic) NSObject<OS_dispatch_queue> *recordQueue; // @synthesize recordQueue=_recordQueue;
@property(readonly, nonatomic) NSString *UUID; // @synthesize UUID=_UUID;
- (float)circularBufferInputRecordingDuration;	// IMP=0x0010000000057da2
- (int)circularBufferNumInputChannel;	// IMP=0x0010000000057d11
- (void)CSPhoneCallStateMonitor:(id)arg1 didRecievePhoneCallStateChange:(unsigned long long)arg2;	// IMP=0x0010000000057cc2
- (void)_updateRemoteDeviceIdFromAVVCIfNeeded;	// IMP=0x0010000000057a48
- (_Bool)_shouldHandleStartPendingOnStopping:(unsigned long long)arg1 withStopReason:(long long)arg2;	// IMP=0x00100000000577c4
- (void)_clearDidStopRecordingDelegateWatchDog;	// IMP=0x0010000000057714
- (void)_scheduleDidStopRecordingDelegateWatchDog:(id)arg1;	// IMP=0x001000000005758e
- (void)_scheduleDidStopRecordingDelegateWatchDog;	// IMP=0x00100000000573fb
- (void)_clearDidStartRecordingDelegateWatchDog;	// IMP=0x001000000005734b
- (void)_schduleDidStartRecordingDelegateWatchDogWithToken:(id)arg1;	// IMP=0x0010000000057185
- (void)_scheduleDidStartRecordingDelegateWatchDog;	// IMP=0x0010000000056ff2
- (void)_onAudioPacketWatchdogFire;	// IMP=0x0010000000056ed4
- (void)_cancelAudioPacketWatchDog;	// IMP=0x0010000000056e95
- (void)_scheduleAudioPacketWatchDog;	// IMP=0x0010000000056d90
- (void)_holdRecordingExceptionIfNeeded:(_Bool)arg1;	// IMP=0x0010000000056c7c
- (void)_releaseRecordingTransactionIfNeeded;	// IMP=0x0010000000056a5b
- (void)_holdRecordingTransactionIfNeeded;	// IMP=0x00100000000569b4
- (id)_streamStateName:(unsigned long long)arg1;	// IMP=0x00100000000567d9
- (void)_handleAudioSystemFailure;	// IMP=0x001000000005664b
- (void)CSAudioServerCrashMonitorDidReceiveServerRestart:(id)arg1;	// IMP=0x001000000005653b
- (void)CSAudioServerCrashMonitorDidReceiveServerCrash:(id)arg1;	// IMP=0x001000000005641c
- (void)audioRecorderDisconnected:(id)arg1;	// IMP=0x00100000000562fd
- (void)audioRecorder:(id)arg1 didSetAudioSessionActive:(_Bool)arg2;	// IMP=0x0010000000056258
- (void)audioRecorder:(id)arg1 willSetAudioSessionActive:(_Bool)arg2;	// IMP=0x00100000000561b3
- (void)audioRecorderEndRecordInterruption:(id)arg1;	// IMP=0x0010000000056116
- (void)audioRecorderBeginRecordInterruption:(id)arg1 withContext:(id)arg2;	// IMP=0x001000000005606c
- (void)audioRecorderBeginRecordInterruption:(id)arg1;	// IMP=0x0010000000055fcf
- (void)audioRecorderBuiltInAudioStreamInvalidated:(id)arg1 error:(id)arg2;	// IMP=0x0010000000055f42
- (void)notifyProviderContextChanged;	// IMP=0x0010000000055ef7
- (void)audioRecorderDidFinishAlertPlayback:(id)arg1 ofType:(long long)arg2 error:(id)arg3;	// IMP=0x0010000000055e53
- (void)_didReceiveFinishStartAlertPlaybackAt:(unsigned long long)arg1;	// IMP=0x0010000000055b87
- (void)_scheduleAlertFinishTimeout:(double)arg1;	// IMP=0x0010000000055a30
- (void)audioRecorderRecordHardwareConfigurationDidChange:(id)arg1 toConfiguration:(long long)arg2;	// IMP=0x00100000000559e1
- (_Bool)isNarrowBand;	// IMP=0x0010000000055953
- (_Bool)isRecording;	// IMP=0x00100000000558c5
- (void)audioRecorderBufferAvailable:(id)arg1 audioStreamHandleId:(unsigned long long)arg2 buffer:(id)arg3;	// IMP=0x0010000000055827
- (void)_forwardAudioChunkForTV:(id)arg1 toStream:(id)arg2;	// IMP=0x0010000000055681
- (void)audioRecorderBufferAvailable:(id)arg1 audioStreamHandleId:(unsigned long long)arg2 buffer:(id)arg3 remoteVAD:(id)arg4 atTime:(unsigned long long)arg5 arrivalTimestampToAudioRecorder:(unsigned long long)arg6 numberOfChannels:(int)arg7;	// IMP=0x00100000000552ec
- (void)_deliverPostprocessAudioChunk:(id)arg1 toStream:(id)arg2 lastForwardedSampleCount:(unsigned long long)arg3;	// IMP=0x001000000005522f
- (void)_forwardAudioChunk:(id)arg1 toStream:(id)arg2;	// IMP=0x0010000000054fb0
- (void)_processAudioBuffer:(id)arg1 remoteVAD:(id)arg2 atTime:(unsigned long long)arg3 arrivalTimestampToAudioRecorder:(unsigned long long)arg4 numberOfChannels:(int)arg5;	// IMP=0x0010000000054ac7
- (void)_deliverHistoricalAudioToStreamsWithRemoteVAD:(id)arg1;	// IMP=0x001000000005476b
- (void)_fetchHistoricalAudioAndForwardToStream:(id)arg1 remoteVAD:(id)arg2;	// IMP=0x0010000000053eda
- (void)audioRecorderWillBeDestroyed:(id)arg1;	// IMP=0x0010000000053e8f
- (void)_handleAudioRecorderStreamHandleIdInvalidated:(unsigned long long)arg1;	// IMP=0x0010000000053ce7
- (void)audioRecorderStreamHandleIdInvalidated:(unsigned long long)arg1;	// IMP=0x0010000000053c98
- (void)audioRecorderDidStopRecord:(id)arg1 audioStreamHandleId:(unsigned long long)arg2 reason:(long long)arg3;	// IMP=0x0010000000053c45
- (void)audioRecorderDidStartRecord:(id)arg1 audioStreamHandleId:(unsigned long long)arg2 successfully:(_Bool)arg3 error:(id)arg4;	// IMP=0x0010000000053ba3
- (void)audioPreprocessor:(id)arg1 hasAvailableBuffer:(id)arg2 atTime:(unsigned long long)arg3 arrivalTimestampToAudioRecorder:(unsigned long long)arg4 numberOfChannels:(int)arg5;	// IMP=0x0010000000053afa
- (_Bool)_shouldStopRecording;	// IMP=0x00100000000538bc
- (void)triggerInfoForContext:(id)arg1 completion:(CDUnknownBlockType)arg2;	// IMP=0x0010000000053805
- (float)averagePowerForChannel:(unsigned long long)arg1;	// IMP=0x00100000000537ae
- (float)peakPowerForChannel:(unsigned long long)arg1;	// IMP=0x0010000000053757
- (void)updateMeters;	// IMP=0x001000000005371a
- (void)setMeteringEnabled:(_Bool)arg1;	// IMP=0x00100000000536d0
- (id)audioMetric;	// IMP=0x0010000000053680
- (void)configureAlertBehavior:(id)arg1;	// IMP=0x001000000005367a
- (unsigned long long)alertStartTime;	// IMP=0x00100000000534e0
- (_Bool)playRecordStartingAlertAndResetEndpointerWithAlertOverride:(long long)arg1;	// IMP=0x00100000000532e4
- (_Bool)_didPlayStartAlertSoundForSiri:(id)arg1 audioStream:(id)arg2;	// IMP=0x00100000000532d3
- (_Bool)playAlertSoundForType:(long long)arg1;	// IMP=0x0010000000053125
- (_Bool)setAlertSoundFromURL:(id)arg1 forType:(long long)arg2 force:(_Bool)arg3;	// IMP=0x0010000000052f51
- (MISSING_TYPE *)setAudioAlertDelegate: /* Error: Ran out of types for this method. */;	// IMP=0x0010000000052ec4
- (void)setAnnounceCallsEnabled:(_Bool)arg1 withStreamHandleID:(unsigned long long)arg2;	// IMP=0x0010000000052e71
- (void)enableMiniDucking:(_Bool)arg1;	// IMP=0x0010000000052e23
- (void)setDuckOthersOption:(_Bool)arg1;	// IMP=0x0010000000052d49
- (void)enableSmartRoutingConsideration:(_Bool)arg1;	// IMP=0x0010000000052cfb
- (_Bool)_deactivateAudioSession:(unsigned long long)arg1 error:(id *)arg2;	// IMP=0x00100000000529e3
- (_Bool)deactivateAudioSession:(unsigned long long)arg1 error:(id *)arg2;	// IMP=0x00100000000527da
- (_Bool)_isDuckingOnSpeakerOutputSupportedWithCurrentRoute;	// IMP=0x0010000000052660
- (_Bool)_shouldDuckOnBuiltInSpeaker;	// IMP=0x0010000000052451
- (_Bool)_activateAudioSessionWithReason:(unsigned long long)arg1 error:(id *)arg2;	// IMP=0x0010000000052087
- (_Bool)activateAudioSessionWithReason:(unsigned long long)arg1 dynamicAttribute:(unsigned long long)arg2 bundleID:(id)arg3 error:(id *)arg4;	// IMP=0x0010000000051e55
- (_Bool)prewarmAudioSessionWithError:(id *)arg1;	// IMP=0x0010000000051c51
- (void)setAudioSessionDelegate:(id)arg1;	// IMP=0x0010000000051bc4
- (id)playbackRoute;	// IMP=0x0010000000051b0b
- (id)recordSettings;	// IMP=0x0010000000051a52
- (id)audioDeviceInfo;	// IMP=0x0010000000051999
- (id)recordDeviceInfo;	// IMP=0x00100000000518e0
- (id)recordRoute;	// IMP=0x0010000000051827
- (void)cancelAudioStreamHold:(id)arg1;	// IMP=0x0010000000051698
- (void)_cancelAudioStreamHold:(id)arg1;	// IMP=0x00100000000512fa
- (void)_didFireStreamHolderTimeout:(id)arg1;	// IMP=0x00100000000511bc
- (void)_holdAudioStreamWithHolder:(id)arg1 option:(id)arg2;	// IMP=0x0010000000050eda
- (id)holdAudioStreamWithDescription:(id)arg1 option:(id)arg2;	// IMP=0x0010000000050c7b
- (void)_saveRecordingBufferFrom:(unsigned long long)arg1 to:(unsigned long long)arg2 toURL:(id)arg3;	// IMP=0x0010000000050b8e
- (void)saveRecordingBufferFrom:(unsigned long long)arg1 to:(unsigned long long)arg2 toURL:(id)arg3;	// IMP=0x0010000000050aec
- (void)saveRecordingBufferToEndFrom:(unsigned long long)arg1 toURL:(id)arg2;	// IMP=0x0010000000050a4c
- (id)_audioChunkFrom:(unsigned long long)arg1 to:(unsigned long long)arg2 channelIdx:(unsigned long long)arg3;	// IMP=0x00100000000509f5
- (id)_audioChunkFrom:(unsigned long long)arg1 to:(unsigned long long)arg2;	// IMP=0x00100000000509a4
- (id)audioChunkToEndFrom:(unsigned long long)arg1 channelIdx:(unsigned long long)arg2;	// IMP=0x00100000000508e2
- (id)audioChunkToEndFrom:(unsigned long long)arg1;	// IMP=0x0010000000050825
- (id)audioChunkFrom:(unsigned long long)arg1 to:(unsigned long long)arg2 channelIdx:(unsigned long long)arg3;	// IMP=0x0010000000050756
- (id)audioChunkFrom:(unsigned long long)arg1 to:(unsigned long long)arg2;	// IMP=0x0010000000050694
- (void)_stopAudioStream:(id)arg1 option:(id)arg2 completion:(CDUnknownBlockType)arg3;	// IMP=0x00100000000504d2
- (void)stopAudioStream:(id)arg1 option:(id)arg2 completion:(CDUnknownBlockType)arg3;	// IMP=0x00100000000503ed
- (void)_handleDidStopAudioStreamWithReason:(long long)arg1;	// IMP=0x001000000004fe6c
- (void)_postEpilogueAudioStream;	// IMP=0x001000000004fe0f
- (void)_preEpilogueAudioStream;	// IMP=0x001000000004fdc4
- (void)_handleDidStartAudioStreamWithResult:(_Bool)arg1 error:(id)arg2;	// IMP=0x001000000004fac8
- (void)_resetCircularBufferStartTime;	// IMP=0x001000000004fa96
- (void)_switchToListeningMode;	// IMP=0x001000000004f9fe
- (void)_switchToRecordingMode;	// IMP=0x001000000004f994
- (void)_forceReleaseAllRecordModeLocks;	// IMP=0x001000000004f93c
- (void)_forceReleaseRecordModeLockFrom:(unsigned long long)arg1;	// IMP=0x001000000004f5cd
- (void)_releaseRecordModeLock:(id)arg1;	// IMP=0x001000000004f439
- (id)_acquireRecordModeLockFrom:(unsigned long long)arg1;	// IMP=0x001000000004f306
- (_Bool)_clearListeningMicIndicatorProperty;	// IMP=0x001000000004f243
- (_Bool)_setListeningMicIndicatorProperty;	// IMP=0x001000000004f180
- (void)_clearListeningMicIndicatorPropertyIfNeeded;	// IMP=0x001000000004f114
- (void)_setListeningMicIndicatorPropertyIfNeeded;	// IMP=0x001000000004f0a8
- (void)_forceReleaseAllListeningMicIndicatorLocks;	// IMP=0x001000000004f050
- (void)_forceReleaseListeningMicIndicatorLockFrom:(unsigned long long)arg1;	// IMP=0x001000000004ed1f
- (void)_releaseListeningMicIndicatorLock:(id)arg1;	// IMP=0x001000000004ebca
- (id)_acquireListeningMicIndicatorLockFrom:(unsigned long long)arg1;	// IMP=0x001000000004ea62
- (void)_startAudioStream:(id)arg1 option:(id)arg2 completion:(CDUnknownBlockType)arg3;	// IMP=0x001000000004d095
- (void)prepareAudioStream:(id)arg1 request:(id)arg2 completion:(CDUnknownBlockType)arg3;	// IMP=0x001000000004ce73
- (_Bool)prepareAudioStreamSync:(id)arg1 request:(id)arg2 error:(id *)arg3;	// IMP=0x001000000004cb8b
- (void)startAudioStream:(id)arg1 option:(id)arg2 completion:(CDUnknownBlockType)arg3;	// IMP=0x001000000004c926
- (void)_createCircularBufferIfNeededWithNumChannel:(unsigned long long)arg1 playbackRoute:(id)arg2;	// IMP=0x001000000004c6ca
- (void)_prepareAudioStream:(id)arg1 request:(id)arg2 completion:(CDUnknownBlockType)arg3;	// IMP=0x001000000004c5b1
- (_Bool)_prepareAudioStreamSync:(id)arg1 request:(id)arg2 error:(id *)arg3;	// IMP=0x001000000004bf32
- (void)attachTandemStream:(id)arg1 toPrimaryStream:(id)arg2 completion:(CDUnknownBlockType)arg3;	// IMP=0x001000000004be56
- (void)audioStreamWithRequest:(id)arg1 streamName:(id)arg2 completion:(CDUnknownBlockType)arg3;	// IMP=0x001000000004bd10
- (id)audioStreamWithRequest:(id)arg1 streamName:(id)arg2 error:(id *)arg3;	// IMP=0x001000000004bb7d
- (id)_audioStreamWithRequest:(id)arg1 streamName:(id)arg2 error:(id *)arg3;	// IMP=0x001000000004b893
- (_Bool)setCurrentContext:(id)arg1 error:(id *)arg2;	// IMP=0x001000000004b64c
- (_Bool)supportsDuckingOnCurrentRouteWithError:(id *)arg1;	// IMP=0x001000000004b488
- (_Bool)_canSetContext;	// IMP=0x001000000004b409
- (unsigned long long)audioStreamId;	// IMP=0x001000000004b3fc
- (void)_setLatestRecordContext:(id)arg1;	// IMP=0x001000000004b313
- (void)setLatestRecordContext:(id)arg1 streamType:(long long)arg2;	// IMP=0x001000000004b273
- (void)setAudioProviderDelegate:(id)arg1;	// IMP=0x001000000004b1e6
- (void)start;	// IMP=0x001000000004ae96
- (void)dealloc;	// IMP=0x001000000004ade3
- (id)initWithAudioStreamHandleId:(unsigned long long)arg1 audioStreamType:(long long)arg2 audioRecordContext:(id)arg3 audioRecorder:(id)arg4;	// IMP=0x001000000004adc0
- (id)initWithAudioStreamHandleId:(unsigned long long)arg1 audioStreamType:(long long)arg2 audioRecordContext:(id)arg3 audioRecorder:(id)arg4 phoneCallStateMonitor:(id)arg5;	// IMP=0x001000000004a76c

// Remaining properties
@property(readonly, copy) NSString *debugDescription;
@property(readonly, copy) NSString *description;
@property(readonly) unsigned long long hash;
@property(readonly) Class superclass;

@end

